/**
	 * expr parses strings in the language generated by the rule: <expr> -> <term>
	 * {(+ | -) <term>}
	 */
	private static void expr() {
		System.out.println("Enter <expr>");

		// parse the first term:
		term();

		// as long as the next token is + or -,
		// get the next token and parse the next term:
		while (nextToken == Token.ADD_OP || nextToken == Token.SUB_OP) {
			lex();
			term();
		}

		System.out.println("Exit <expr>");
	}

	/**
	 * term parses strings in the language generated by the rule: <term> -> <factor>
	 * {(* | /) <factor>}
	 */
	private static void term() {
		System.out.println("Enter <term>");

		// parse the first factor
		factor();

		// as long as the next token is * or /,
		// get the next token and parse the next factor
		while (nextToken == Token.MULT_OP || nextToken == Token.DIV_OP) {
			lex();
			factor();
		}

		System.out.println("Exit <term>");
	}

	/**
	 * factor parses strings in the language generated by the rule: <factor> -> id |
	 * int_constant | ( <expr> )
	 */
	private static void factor() {
		System.out.println("Enter <factor>");

		// determine which RHS
		if (nextToken == Token.IDENT || nextToken == Token.INT_LIT) {
			// get the next token
			lex();
		}

		// If the RHS is ( <expr> ),
		// call lex to pass over the left parenthesis,
		// call expr, and check for the right parenthesis
		else {
			if (nextToken == Token.LEFT_PAREN) {
				lex();
				expr();
				if (nextToken == Token.RIGHT_PAREN) {
					lex();
				} else {
					error();
				}
			}

			// it was not an id, an integer literal, or a left parenthesis:
			else {
				error();
			}
		}

		System.out.println("Exit <factor>");
	}

	/**
	 * error Handles improper syntax with a message
	 */
	private static void error() {
		errorState = true;
		System.out.println("There is a syntax error here.");
	}
}